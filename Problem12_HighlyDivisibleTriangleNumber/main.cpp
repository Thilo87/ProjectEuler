/*

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

*/

#include <iostream>
#include "stoppuhr.h"
#include "teiler.h"
#include <cmath>
using namespace std ;

int main ()
{
	stoppUhr( START ) ;

	unsigned long long dreieckszahl = 1 ;
	for ( int i = 2 ;  true ;  ++i )
	{
		dreieckszahl += i ;
		if ( teileranzahl( dreieckszahl ) > 500 )
		{
			cout << dreieckszahl ;
			break ;
		}
	}

	cout << endl ;
	cout << stoppUhr( STOPP ) << "s" << endl ;
	return 0 ;
}

//// ermittelt die Teileranzahl, indem jede Zahl von 1 bis n ausprobiert wird, ob sie n teilt
//int teileranzahl_v1( unsigned long long n )
//{
//	int teiler = 0 ;
//	for ( int i = 1 ;  i <= n ;  ++i )
//		if ( n % i == 0 )
//			++teiler ;
//
//	return teiler ;
//}
//
//// ermittelt die Teileranzahl, indem jede Zahl von 1 bis n/2 ausprobiert wird, ob sie n teilt
//int teileranzahl_v2( unsigned long long n )
//{
//	int teiler = 1 ;
//	for ( int i = 1 ;  i <= n/2 ;  ++i )
//		if ( n % i == 0 )
//			++teiler ;
//
//	return teiler ;
//}
//
//// ermittelt die Teileranzahl, indem jede Zahl von 2 bis einer oberen Grenze ausprobiert wird, ob sie n teilt.
//// dabei ist die obere Grenze der kleinste Gegenteiler einer Zahl, die bereits als Teiler identifiziert wurde
//int teileranzahl_v3( unsigned long long n )
//{
//	int teiler = 2 ; // n und 1 sind bereits inbegriffen
//
//	unsigned long long obereGrenze = n/2 ;
//
//	unsigned long long i = 2 ;
//	while ( i < obereGrenze )
//	{
//		if ( n % i == 0 )
//		{
//			teiler += 2 ;
//			obereGrenze = n / i ;
//			
//			// wichtig, da sonst bei manchen Zahlen ein Teiler zu viel berechnet wird
//			if ( obereGrenze == i )
//				--teiler ;
//		}
//
//		++i ;
//	}
//
//	return teiler ;
//}